(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{485:function(t,r,a){t.exports=a.p+"assets/img/binaryTree.5e255f73.png"},486:function(t,r,a){t.exports=a.p+"assets/img/order.e2111d97.png"},487:function(t,r,a){t.exports=a.p+"assets/img/fullbinaryTree.075897c8.png"},488:function(t,r,a){t.exports=a.p+"assets/img/completeBinaryTree.c54b74e6.png"},592:function(t,r,a){"use strict";a.r(r);var s=a(4),e=Object(s.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一、二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、二叉树"}},[t._v("#")]),t._v(" 一、二叉树")]),t._v(" "),s("p",[t._v("二叉树是每个节点最多拥有两个子节点，左子树和右子树是有顺序的不能任意颠倒。\n"),s("img",{attrs:{src:a(485),alt:"二叉树"}})]),t._v(" "),s("h2",{attrs:{id:"二、二叉树的遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、二叉树的遍历"}},[t._v("#")]),t._v(" 二、二叉树的遍历")]),t._v(" "),s("p",[t._v("前序遍历（前根遍历）：根——>左——>右")]),t._v(" "),s("p",[t._v("中序遍历（中根遍历）：左——>根——>右")]),t._v(" "),s("p",[t._v("后序遍历（后根遍历）：左——>右——>根")]),t._v(" "),s("p",[t._v("已知前序和中序，求后序问题，  前序 ABDGCEFH    中序 DGBAECHF")]),t._v(" "),s("p",[t._v("解法：根据前序、中序综合判断画出树的节点图，然后再写后序遍历：DGBEHFCA")]),t._v(" "),s("p",[t._v("（前序和中序的子树也满足前序或中序的规则）")]),t._v(" "),s("p",[s("img",{attrs:{src:a(486),alt:"二叉树遍历"}})]),t._v(" "),s("p",[t._v("二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）")]),t._v(" "),s("p",[t._v("DFS深度优先遍历：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。利用数据结构“栈”，父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点。")]),t._v(" "),s("p",[t._v("DFS:ABDGCEFH")]),t._v(" "),s("p",[t._v("BFS广度优先遍历：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。利用数据结构“队列”，父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点。")]),t._v(" "),s("p",[t._v("BFS：ABCDGEFH")]),t._v(" "),s("h2",{attrs:{id:"三、满二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、满二叉树"}},[t._v("#")]),t._v(" 三、满二叉树")]),t._v(" "),s("p",[t._v("高度为h，由2^h-1个节点构成的二叉树称为满二叉树。"),s("br"),t._v(" "),s("img",{attrs:{src:a(487),alt:"满二叉树"}})]),t._v(" "),s("h2",{attrs:{id:"四、完全二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、完全二叉树"}},[t._v("#")]),t._v(" 四、完全二叉树")]),t._v(" "),s("p",[t._v("完全二叉树是由满二叉树而引出来的，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。")]),t._v(" "),s("p",[t._v("堆一般都是用完全二叉树来实现的。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(488),alt:"完全二叉树"}})]),t._v(" "),s("h2",{attrs:{id:"五、二叉搜索树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、二叉搜索树"}},[t._v("#")]),t._v(" 五、二叉搜索树")]),t._v(" "),s("p",[t._v("二叉搜索树（英语：Binary Search Tree），也称为二叉查找树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：")]),t._v(" "),s("ul",[s("li",[t._v("若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；")]),t._v(" "),s("li",[t._v("若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；")]),t._v(" "),s("li",[t._v("任意节点的左、右子树也分别为二叉查找树；")]),t._v(" "),s("li",[t._v("没有键值相等的节点。")])]),t._v(" "),s("p",[t._v("二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，O（logN）。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构。")])])}),[],!1,null,null,null);r.default=e.exports}}]);