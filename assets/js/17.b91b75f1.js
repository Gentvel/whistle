(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{563:function(e,t,r){e.exports=r.p+"assets/img/reactor1.732c2304.png"},564:function(e,t,r){e.exports=r.p+"assets/img/reactor2.aaa30015.png"},565:function(e,t,r){e.exports=r.p+"assets/img/reactor4.59ffa3d2.png"},566:function(e,t,r){e.exports=r.p+"assets/img/reactor3.eecb022e.png"},688:function(e,t,r){"use strict";r.r(t);var a=r(4),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"架构演变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构演变"}},[e._v("#")]),e._v(" 架构演变")]),e._v(" "),a("h3",{attrs:{id:"原生nio存在的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生nio存在的问题"}},[e._v("#")]),e._v(" 原生NIO存在的问题")]),e._v(" "),a("p",[e._v("NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。")]),e._v(" "),a("p",[e._v("需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。")]),e._v(" "),a("p",[e._v("开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。")]),e._v(" "),a("p",[e._v("JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。")]),e._v(" "),a("h3",{attrs:{id:"i-o线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o线程模型"}},[e._v("#")]),e._v(" I/O线程模型")]),e._v(" "),a("p",[e._v("目前存在的线程模型主要有：")]),e._v(" "),a("ul",[a("li",[e._v("传统阻塞I/O服务模型")]),e._v(" "),a("li",[e._v("Reactor模式")])]),e._v(" "),a("p",[e._v("根据Reactor的数量和处理资源池线程的数量不同，有如下3种典型的实现")]),e._v(" "),a("ul",[a("li",[e._v("单Reactor单线程")]),e._v(" "),a("li",[e._v("单Reactor多线程")]),e._v(" "),a("li",[e._v("主从Reactor多线程")])]),e._v(" "),a("p",[e._v("Netty线程模型主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor。")]),e._v(" "),a("h2",{attrs:{id:"单reactor单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单reactor单线程"}},[e._v("#")]),e._v(" 单Reactor单线程")]),e._v(" "),a("center",[a("p",[a("img",{attrs:{src:r(563),alt:"reactor"}})])]),e._v(" "),a("ul",[a("li",[e._v("Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求")]),e._v(" "),a("li",[e._v("Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发")]),e._v(" "),a("li",[e._v("如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理")]),e._v(" "),a("li",[e._v("如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应")]),e._v(" "),a("li",[e._v("Handler 会完成 Read→业务处理→Send 的完整业务流程")])]),e._v(" "),a("h2",{attrs:{id:"单reactor多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单reactor多线程"}},[e._v("#")]),e._v(" 单Reactor多线程")]),e._v(" "),a("center",[a("p",[a("img",{attrs:{src:r(564),alt:"reactor"}})])]),e._v(" "),a("ul",[a("li",[e._v("Reactor 对象通过select 监控客户端请求\v事件, 收到事件后，通过dispatch进行分发")]),e._v(" "),a("li",[e._v("如果建立连接请求, 则右Acceptor 通过\vaccept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件")]),e._v(" "),a("li",[e._v("如果不是连接请求，则由reactor分发调用连接对应的handler 来处理")]),e._v(" "),a("li",[e._v("handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务")]),e._v(" "),a("li",[e._v("worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler")]),e._v(" "),a("li",[e._v("handler收到响应后，通过send 将结果返回给client")])]),e._v(" "),a("h2",{attrs:{id:"主从reactor多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从reactor多线程"}},[e._v("#")]),e._v(" 主从Reactor多线程")]),e._v(" "),a("center",[a("p",[a("img",{attrs:{src:r(565),alt:"reactor"}})])]),e._v(" "),a("ul",[a("li",[e._v("Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件")]),e._v(" "),a("li",[e._v("当 Acceptor  处理连接事件后，MainReactor 将连接分配给SubReactor")]),e._v(" "),a("li",[e._v("subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理")]),e._v(" "),a("li",[e._v("当有新事件发生时， subreactor 就会调用对应的handler处理")]),e._v(" "),a("li",[e._v("handler 通过read 读取数据，分发给后面的worker 线程处理")]),e._v(" "),a("li",[e._v("worker 线程池分配独立的worker 线程进行业务处理，并返回结果")]),e._v(" "),a("li",[e._v("handler 收到响应的结果后，再通过send 将结果返回给client")]),e._v(" "),a("li",[e._v("Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor")])]),e._v(" "),a("h2",{attrs:{id:"netty-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#netty-架构"}},[e._v("#")]),e._v(" Netty 架构")]),e._v(" "),a("center",[a("p",[a("img",{attrs:{src:r(566),alt:"netty"}})])]),e._v(" "),a("ul",[a("li",[e._v("Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写")]),e._v(" "),a("li",[e._v("BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup")]),e._v(" "),a("li",[e._v("NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop")]),e._v(" "),a("li",[e._v("NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯")]),e._v(" "),a("li",[e._v("NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop")]),e._v(" "),a("li",[e._v("每个Boss NioEventLoop 循环执行的步骤有3步\n"),a("ol",[a("li",[e._v("轮询accept 事件")]),e._v(" "),a("li",[e._v("处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的 selector")]),e._v(" "),a("li",[e._v("处理任务队列的任务 ， 即 runAllTasks")])])]),e._v(" "),a("li",[e._v("每个 Worker NIOEventLoop 循环执行的步骤\n"),a("ol",[a("li",[e._v("轮询read, write 事件")]),e._v(" "),a("li",[e._v("处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理任务队列的任务 ， 即 runAllTasks")])])]),e._v(" "),a("li",[e._v("每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器")])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);