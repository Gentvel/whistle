(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{521:function(s,t,a){s.exports=a.p+"assets/img/transactional.0090ef4b.png"},636:function(s,t,a){"use strict";a.r(t);var e=a(4),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[s._v("#")]),s._v(" 简介")]),s._v(" "),e("p",[s._v("当redis在执行指令的过程中，多条连续执行的指令被干扰，打断，插队。")]),s._v(" "),e("p",[s._v("redis事务就是一个命令的执行队列，将一系列预定义的命令包装成一个整体。当执行时，一次性按照添加顺序一次执行，中间不会被打断或者干扰。")]),s._v(" "),e("h2",{attrs:{id:"事务的基本操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务的基本操作"}},[s._v("#")]),s._v(" 事务的基本操作")]),s._v(" "),e("ul",[e("li",[s._v("开启事务 "),e("code",[s._v("multi")]),e("br"),s._v("\n设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中")]),s._v(" "),e("li",[s._v("执行事务 "),e("code",[s._v("exec")]),e("br"),s._v("\n设定事务的结束位置，同时执行事务，与muti成对出现，成对使用")])]),s._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" multi\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" name "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("12")]),s._v("\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" name "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("13")]),s._v("\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" lpush age "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("12")]),s._v("\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" incr age\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("exec")]),s._v("\nOK\nOK\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" lrange age "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" -1\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("12")]),s._v("\n\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",[s._v("加入事务的命令展示进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行")])]),s._v(" "),e("p",[s._v("当在事务定义过程中出现问题，可以使用"),e("code",[s._v("discard")]),s._v("取消事务，终止当前事务，发生在muti之后，exec之前")]),s._v(" "),e("p",[s._v("redis事务整体流程图如下：")]),s._v(" "),e("center",[e("p",[e("img",{attrs:{src:a(521),alt:"Redis Transactional"}})])]),s._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),e("p",[s._v("在定义事务过程中，命令"),e("strong",[s._v("格式输入错误")]),s._v("会将整体事务中所有命令均不执行，包括语法正确的命令。"),e("br"),s._v("\n在定义事务过程中，"),e("strong",[s._v("命令执行出现错误")]),s._v("（比如：list进行incr操作）那么事务中能够正常运行的命令会执行，运行错误的命令不会被执行"),e("br"),s._v("\n（特别特别要注意的是已执行完毕的命令对应的数据不会自动回滚，需要程序员在代码中实现回滚）")])]),s._v(" "),e("h2",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[s._v("#")]),s._v(" 锁")]),s._v(" "),e("p",[s._v("基于特定条件的事务执行用锁控制\n对key添加监视锁，在执行exec前如果key发生了变化，终止执行事务")]),s._v(" "),e("p",[e("code",[s._v("watch key1 [key2 ...]")])]),s._v(" "),e("p",[s._v("取消对所有key的监视")]),s._v(" "),e("p",[e("code",[s._v("unwatch")])]),s._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("###########1watch 在multi内")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" multi\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("watch")]),s._v(" name\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" age "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),s._v("\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("exec")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#执行之前另一个客户端修改了name的值")]),s._v("\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" get name\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("111")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("###########1watch 在multi外")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("watch")]),s._v(" name\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" multi\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" age "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("111")]),s._v("\nQUEUED\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("exec")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#执行之前另一个客户端修改了name的值")]),s._v("\nnull\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" get  name\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("12")]),s._v("\n\n")])])]),e("p",[s._v("由以上第二部的multi操作可以看出，当watch的值发生改变，那么执行exec指令的时候将会返回null")]),s._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),e("p",[s._v("watch 操作应该在事务之前执行，如果放在事务里面，那么watch的键值如果发生改变也不会影响\n（测试版本为6.0.6）如果为5.0之前的版本将会报错 :ERR WATCH inside MULTI is not allowed")])]),s._v(" "),e("p",[s._v("通常事务和锁的操作都应用与基于状态控制的批量任务执行")]),s._v(" "),e("p",[s._v("但是为了在热卖情况下发生超卖的这种问题：")]),s._v(" "),e("ul",[e("li",[s._v("使用watch监控一个key有没有改变时不能解决问题的，因为此时需要监控key的具体数值是否发生改变。")]),s._v(" "),e("li",[s._v("redis是单线程的，但是多个客户端对同一数据同时进行操作，该怎么避免key的值同时被修改？")])]),s._v(" "),e("h2",{attrs:{id:"分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),e("p",[s._v("基于特定条件的事务执行，分布式锁\n使用setnx 设置一个公共锁")]),s._v(" "),e("p",[e("code",[s._v("setnx lock-key value")])]),s._v(" "),e("p",[s._v("利用setnx命令的返回值特征，"),e("strong",[s._v("有值则返回设置失败，无值则返回设置成功")])]),s._v(" "),e("ul",[e("li",[s._v("对于返回设置成功的锁，拥有控制权，进行下一步的具体业务操作")]),s._v(" "),e("li",[s._v("对于返回设置失败的锁，不具有控制权，排队或等待\n操作完毕后使用del操作释放锁")])]),s._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\nOK\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock-num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" incrby num -1\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("9")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" del lock-num\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock-num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" \n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" incrby num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("############另一客户端操作")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock-num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("###########操作结束")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" del lock-num\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("############另一客户端操作")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock-num "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("###########操作结束")]),s._v("\n")])])]),e("p",[s._v("可以看到，在redis中，具体锁的不是具体操作的key，而是自定义的另外一个lockname，这样的情况下，每个客户端都要遵循统一锁的名称，如果锁名称不统一那么分布式锁也就无意义了。特别注意在业务操作完成之后一定要释放锁")]),s._v(" "),e("h3",{attrs:{id:"业务场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#业务场景"}},[s._v("#")]),s._v(" 业务场景")]),s._v(" "),e("p",[s._v("依赖分布式锁的机制，某个用户操作时对应的客户端宕机，且此时已经获取到锁，那该怎么办呢？")]),s._v(" "),e("p",[s._v("分析：")]),s._v(" "),e("ul",[e("li",[s._v("由于锁操作是由用户控制加锁解锁的，必定存在加锁后未解锁的风险")]),s._v(" "),e("li",[s._v("需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案")])]),s._v(" "),e("p",[s._v("这个时候就可以使用系统提供的方案expire\n使用expire为锁的key添加时间限定，如果超过时间还不释放，那么将会放弃该锁")]),s._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("expire lock-key second\npexpire lock-key milliseconds\n")])])]),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" expire lock "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" setnx lock "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])])]),e("p",[s._v("可以看到在设置锁的过期时间后，想要再次获取是获取不到的，在超过锁时效后，将能获取锁")]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[s._v("由于操作redis通常都是微秒或者毫秒级别的，因此锁定时间不宜设置过大。具体时间需要业务测试后确认。")]),s._v(" "),e("ul",[e("li",[s._v("测试持有锁的操作最长执行时间是123ms，最短执行时间是7ms")]),s._v(" "),e("li",[s._v("测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时")]),s._v(" "),e("li",[s._v("锁时间设定一般为："),e("strong",[s._v("最大耗时 * 120% + 平均网络延迟 * 100%")])]),s._v(" "),e("li",[s._v("如果业务最大耗时远小于或远大于网络平均延迟，比如两个数量级的差异，那么取单个耗时较长的即可")])])])],1)}),[],!1,null,null,null);t.default=n.exports}}]);