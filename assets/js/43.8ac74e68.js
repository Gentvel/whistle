(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{582:function(r,t,a){"use strict";a.r(t);var v=a(4),_=Object(v.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h2",{attrs:{id:"一、序言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、序言"}},[r._v("#")]),r._v(" 一、序言")]),r._v(" "),a("p",[r._v("算法的应用不单只体现在变成中。狭义上来说，算法可看作是数据传递和处理的顺序、方法和组成方式，就像是各种排序算法等。而广义的来讲，算法更像是一种事务运行的逻辑和规则，太阳东升西落，月有阴晴圆缺。")]),r._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"./sort"}},[r._v("排序算法")])]),r._v(" "),a("li",[a("a",{attrs:{href:"./recursion"}},[r._v("递归算法思想")])])]),r._v(" "),a("p",[r._v("其实就是一板一眼的东西，它没有什么灵活的。")]),r._v(" "),a("h2",{attrs:{id:"二、穷举法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、穷举法"}},[r._v("#")]),r._v(" 二、穷举法")]),r._v(" "),a("p",[r._v("这是最为简单的思想，也叫枚举算法。顾名思义，就是穷尽列举，将问题可能的解依次列举出来，然后一一带入问题当中校验，从而可以从一系列的可能解中获得能够解决问题的精确解。"),a("br"),r._v("\n穷举法虽然看起来简单，但是其实还是有一些容易被忽视的点。比如说待解决问题的[可能解/候选解]的筛选条件，[可能解]之间的相互影响，穷举[可能解]的代价，[可能解]的穷举方式等。"),a("br"),r._v("\n很多时候实际上不必区追求高大上的复杂算法结构，大道至简，采用枚举法就能很好的规避系统复杂性带来的冗余，同时，或许在一定程度上还能够对所用空间进行缩减。"),a("br"),r._v("\n通过对事先确定好的[可能解]，然后逐一在系统中进行验证，根据验证结果来对[可能解]进行分析和论证。这是一种明显的结果导向型思想，简单粗暴地反向分析可能的结果。\n不过，枚举思想的劣势当然也很明显。在实际的运行程序中，能够直接通过枚举方法进行求解的问题少之又少。而当「可能解」的筛选条件不清晰，导致「可能解」的数量和范围无法准确判断时，枚举就失去了意义。\n然而当「可能解」的规模比较小，同时依次验证的过程容易实施时，枚举思想不失为一种方便快捷的方式。只不过在具体使用时，还可以针对应用场景对「可能解」的验证进行优化。\n这种优化可以从两个方向入手，一是问题的简化，尽可能对需要处理的问题进行模型结构上的精简。这种精简具体可体现在问题中的变量数目，减少变量的数据，从而能够从根本上降低「可能解」的组合。\n二是对筛选「可能解」的范围和条件进行严格判断，尽可能的剔除大部分无效的「可能解」。\n虽说如此，但是一般而言大部分枚举不可用的场景都是由于「可能解」的数量过多，无法在有限空间或有限时间内完成所有可能性的验证。不过实际上枚举思想是最接近人的思维方式，在更多的时候是用来帮助我们去「理解问题」，而不是「解决问题」。")]),r._v(" "),a("h2",{attrs:{id:"三、递推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、递推"}},[r._v("#")]),r._v(" 三、递推")]),r._v(" "),a("p",[r._v("递推思想跟枚举思想一样，都是接近人类思维方式的思想，甚至在实际生活具有比枚举思想更多的应用场景。人脑在遇到未知的问题时，大多数人第一直觉都会从积累的「先验知识」出发，试图从「已知」推导「未知」，从而解决问题，说服自己。"),a("br"),r._v("\n事实上，这就是一种递推的算法思想。递推思想的核心就是从已知条件出发，逐步推算出问题的解。实现方式很像是初高中时我们的数学考卷上一连串的「因为」「所以」。那个时候还是用三个点来表示的。"),a("br"),r._v("\n而对于计算机而言，复杂的推导其实很难实现。计算机擅长的是执行高密度重复性高的工作，对于随机性高变化多端的问题反而不好计算。相比之下，人脑在对不同维度的问题进行推导时具有更高的自由度。"),a("br"),r._v("\n比方说，人脑可以很容易的从「太阳从东边升起」推出「太阳从西边落下」，然后大致推出「现在的时间」。但是对于计算机而言并没有那么容易，你可能需要设置一系列的限制条件，才能避免计算机推出「太阳/月亮/星星」从「南/北/东边」「落下/飞走/掉落」的可能性。")]),r._v(" "),a("h2",{attrs:{id:"四、递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、递归"}},[r._v("#")]),r._v(" 四、递归")]),r._v(" "),a("p",[r._v("说完递推，就不得不说说它的兄弟思想——"),a("a",{attrs:{href:"./recursion"}},[r._v("递归")]),r._v("算法。二者同样都带有一个「递」字，可以看出二者还是具有一定的相似性的。「递」的理解可以是逐次、逐步。在递推中，是逐次对问题进行推导直到获得最终解。而在递归中，则是逐次回归迭代，直到跳出回归。"),a("br"),r._v("\n递归算法实际上是把问题转化成规模更小的同类子问题，先解决子问题，再通过相同的求解过程逐步解决更高层次的问题，最终获得最终的解。所以相较于递推而言，递归算法的范畴更小，要求子问题跟父问题的结构相同。而递推思想从概念上并没有这样的约束。"),a("br"),r._v("\n用一句话来形容递归算法的实现，就是在函数或者子过程的内部，直接或间接的调用自己算法。所以在实现的过程中，最重要的是确定递归过程终止的条件，也就是迭代过程跳出的条件判断。否则，程序会在自我调用中无限循环，最终导致内存溢出而崩溃。")]),r._v(" "),a("h2",{attrs:{id:"五、分治"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、分治"}},[r._v("#")]),r._v(" 五、分治")]),r._v(" "),a("p",[r._v("分治，分而治之。"),a("br"),r._v("\n分治算法的核心步骤就是两步，一是分，二是治。但这还引申出了一系列的问题，为什么分，怎么分，怎么治，治后如何。\n分治算法很像是一种向下管理的思想，从最高级层层划分，将子任务划分给不同的子模块，进而可以进行大问题的拆分，对系统问题的粒度进行细化，寻求最底层的最基本的解。这样的思路在很多领域都有运用，比如几何数学中的正交坐标、单位坐标、基的概念等，都是通过将复杂问题简化为基本的子问题，然后通过先解决子模块再逐步解决主模块。"),a("br"),r._v("\n在实际的运用中，分治算法主要包括两个维度的处理，一是自顶向下，将主要问题划分逐层级划分为子问题；二是自底向上，将子问题的解逐层递增融入主问题的求解中。"),a("br"),r._v("\n那为什么要分？这个很好解释，由于主要问题的规模过大，无法直接求解，所以需要对主要问题进行粒度划分。\n那怎么分？遵循计算机的最擅长的重复运算，划分出来的子问题需要相互独立并且与原问题结构特征相同，这样能够保证解决子问题后，主问题也就能够顺势而解。\n怎么治？这就涉及到最基本子问题的求解，我们约定最小的子问题是能够轻易得到解决的，这样的子问题划分才具有意义，所以在治的环节就是需要对最基本子问题的简易求解。"),a("br"),r._v("\n治后如何？子问题的求解是为了主问题而服务的。当最基本的子问题得到解后，需要层层向上递增，逐步获得更高层次问题的解，直到获得原问题的最终解。")]),r._v(" "),a("h2",{attrs:{id:"六、动态规划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、动态规划"}},[r._v("#")]),r._v(" 六、动态规划")]),r._v(" "),a("p",[r._v("我们知道分治思想最重要的一点是分解出的子问题是相互独立且结构特征相同的。这一点并不是所有问题都能满足，许多问题的划分的子问题往往都是相互重叠且互相影响的，那么就很难使用分治算法进行有效而又干净的子问题划分。"),a("br"),r._v("\n于是乎，动态规划来了。动态规划同样需要将问题划分为多个子问题，但是子问题之间往往不是互相独立的。当前子问题的解可看作是前多个阶段问题的完整总结。因此这就需要在在子问题求解的过程中进行多阶段的决策，同时当前阶段之前的决策都能够构成一种最优的子结构。这就是所谓的最优化原理。"),a("br"),r._v("\n最优化原理，一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。同时，这样的最优策略是针对有已作出决策的总结，对后来的决策没有直接影响，只能借用目前最优策略的状态数据。这也被称之为无后效性。"),a("br"),r._v("\n动态规划是在目前看来非常不接近人类思维方式一种算法，主要原因是在于人脑在演算的过程中很难对每一次决策的结果进行记忆。动态规划在实际的操作中，往往需要额外的空间对每个阶段的状态数据进行保存，以便下次决策的使用。"),a("br"),r._v("\n动归的开始需要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态。然后重点是根据决策的方法来确定状态转移方程。也就是需要根据当前阶段的状态确定下一阶段的状态。"),a("br"),r._v("\n动态规划主要就是用来解决多阶段决策的问题，但是实际问题中往往很难有统一的处理方法，必须结合问题的特点来进行算法的设计，这也是这种算法很难真正掌握的原因。")]),r._v(" "),a("h2",{attrs:{id:"七、贪-心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、贪-心"}},[r._v("#")]),r._v(" 七、贪 心")]),r._v(" "),a("p",[r._v("贪心算法，我愿称之为最现实的算法思想。"),a("br"),r._v("\n人活在世上，不可能每一个选择都那么恰到好处。那么多的问题，不可能所有问题都能找到最优解。很多问题根本没有准确解，甚至于无解。所以在某些场景下，傻傻的去追求问题的最精确解是没有意义的。"),a("br"),r._v("\n有人说，那还有最优解呢。难道最优解都不要了吗？"),a("br"),r._v("\n没错，许多问题虽然找不到最精确的解，但是的确会存在一个或者一些最优解。但是一定要去追求这些最优解吗？我看不一定。\n算法的存在不是单纯的为了对问题求解，更多的是提供一种「策略」。何谓「策略」，解决问题的一种方式，一个角度，一条路。所以，贪心思想是有价值的。\n说回贪心算法。从贪心二字就可得知，这个算法的目的就是为了「贪图更多」。但是这种贪心是「目光短浅」的，这就导致贪心算法无法从长远出发，只看重眼前的利益。"),a("br"),r._v("\n具体点说，贪心算法在执行的过程中，每一次都会选择最大的收益，但是总收益却不一定最大。所以这样傻白甜的思路带来的好处就是选择简单，不需要纠结，不需要考虑未来。"),a("br"),r._v("\n贪心算法的实现过程就是从问题的一个初始解出发，每一次都作出「当前最优」的选择，直至遇到局部极值点。贪心所带来的局限性很明显，就是无法保证最后的解是最优的，很容易陷入局部最优的情况。"),a("br"),r._v("\n但是它每一次做选择的速度很快，同时判断条件简单，能够比较快速的给出一种差不多的解决方案。")]),r._v(" "),a("h2",{attrs:{id:"八、回-溯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、回-溯"}},[r._v("#")]),r._v(" 八、回 溯")]),r._v(" "),a("p",[r._v("简单来说，回溯的过程就是在做出下一步选择之前，先对每一种可能进行试探；只有当可能性存在时才会向前迈进，倘若所有选择都不可能，那么则向后退回原来的位置，重新选择。\n这样看起来，回溯算法很像是一种进行中的枚举算法，在行进的过程中对所有可能性进行枚举并判断。常用的应用场景就在对树结构、图结构以及棋盘落子的遍历上。")]),r._v(" "),a("h2",{attrs:{id:"九、模-拟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、模-拟"}},[r._v("#")]),r._v(" 九、模 拟")]),r._v(" "),a("p",[r._v("模拟思想的理解相比上述思想应该不是什么难事。\n许多真实场景下，由于问题规模过大，变量过多等因素，很难将具体的问题抽象出来，也就无法针对抽象问题的特征来进行算法的设计。这个时候，模拟思想或许是最佳的解题策略。\n模拟的过程就是对真实场景尽可能的模拟，然后通过计算机强大的计算能力对结果进行预测。这相较于上述的算法是一种更为宏大的思想。在进行现实场景的模拟中，可能系统部件的实现都需要上述几个算法思想的参与。\n模拟说起来是一种很玄幻的思想，没有具体的实现思路，也没有具体的优化策略。只能说，具体问题具体分析。")])])}),[],!1,null,null,null);t.default=_.exports}}]);