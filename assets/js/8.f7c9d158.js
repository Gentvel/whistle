(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{537:function(a,e,_){a.exports=_.p+"assets/img/serial_collector.beff703d.png"},538:function(a,e,_){a.exports=_.p+"assets/img/parallel.581bab46.png"},539:function(a,e,_){a.exports=_.p+"assets/img/cms.9ea9682f.png"},540:function(a,e,_){a.exports=_.p+"assets/img/g1.5da50798.png"},541:function(a,e,_){a.exports=_.p+"assets/img/g1_collector.d78d988e.png"},542:function(a,e,_){a.exports=_.p+"assets/img/shenandoah.74d97ce6.png"},543:function(a,e,_){a.exports=_.p+"assets/img/brooks_pointers.10006dab.png"},544:function(a,e,_){a.exports=_.p+"assets/img/colorful_pointer.de90727f.png"},656:function(a,e,_){"use strict";_.r(e);var v=_(4),t=Object(v.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"一、串行回收器-serial收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、串行回收器-serial收集器"}},[a._v("#")]),a._v(" 一、串行回收器(Serial收集器)")]),a._v(" "),v("p",[a._v("串行回收器指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用，根据不同的作用域，分为新生代串行回收器和老年代串行回收器。")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(537),alt:"Serial收集器"}})])]),a._v(" "),v("h3",{attrs:{id:"_1-1-新生代串行回收器（serial）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-新生代串行回收器（serial）"}},[a._v("#")]),a._v(" 1.1 新生代串行回收器（Serial）")]),a._v(" "),v("p",[a._v("串行收集器是所有垃圾回收器中最古老的一种，它有两个特点：")]),a._v(" "),v("ul",[v("li",[a._v("使用单线程进行垃圾回收")]),a._v(" "),v("li",[a._v("独占式的垃圾回收\n在串行收集器进行垃圾回收时，java应用程序中的线程都需要暂停，等待垃圾回收的完成。使用"),v("code",[a._v("-XX:+UseSerialGC")]),a._v("参数可以指定新生代和老年代串行收集器。新生代串行处理器使用复制算法。当虚拟机在Client模式下运行时，它是默认的垃圾回收器。")])]),a._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[a._v("串行垃圾回收器虽然古老，但是久经考验。在大多数情况下，其性能表现是相当不错的。")])]),a._v(" "),v("h3",{attrs:{id:"_1-2-老年代串行回收器（serialold）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-老年代串行回收器（serialold）"}},[a._v("#")]),a._v(" 1.2 老年代串行回收器（SerialOld）")]),a._v(" "),v("p",[a._v("老年代串行收集器使用的是标记压缩算法。和新生代串行收集器一样它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序可能会因此挺短较长的时间。\n可以使用：")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("-XX:+UseSerialGC")]),a._v(":新生代、老年代都使用串行回收器")]),a._v(" "),v("li",[v("code",[a._v("-XX:+UseParNewGC")]),a._v(":新生代使用ParNew回收器，老年代使用串行回收器")]),a._v(" "),v("li",[v("code",[a._v("-XX:+UseParallelGC")]),a._v(":新生代使用ParallelGC回收器，老年代使用串行回收器")])]),a._v(" "),v("h2",{attrs:{id:"二、并行回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、并行回收器"}},[a._v("#")]),a._v(" 二、并行回收器")]),a._v(" "),v("p",[a._v("使用多个线程同时进行垃圾回收。")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(538),alt:"Parallel收集器"}})])]),a._v(" "),v("h3",{attrs:{id:"_2-1-新生代parnew回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-新生代parnew回收器"}},[a._v("#")]),a._v(" 2.1 新生代ParNew回收器")]),a._v(" "),v("p",[a._v("ParNew回收器是工作在新生代的垃圾回收器。简单地将串行回收器多线程化，回收策略、算法以及参数和新生代串行回收器一样。PerNew回收器也是独占式回收器，在收集过程中，应用程序会全部暂停。在多CPU的计算机上使用的话，它的停顿时间要短于串行回收器，而在单CPU或者并发能力较差的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。\n开启PerNew回收器可以使用以下参数：")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("-XX:+UseParNewGC")]),a._v(":新生代使用ParNew回收器，老年代使用串行回收器")]),a._v(" "),v("li",[v("code",[a._v("-XX:+UseConcMarkSweepGC")]),a._v(":新生代使用ParNew回收器，老年代使用CMS")])]),a._v(" "),v("p",[a._v("ParNew回收器工作时的线程数量可以使用"),v("code",[a._v("-XX:ParallelGCThreads")]),a._v("参数指定，一般，最好与CPU数量相当，避免过多的线程数，影响垃圾回收性能。在默认情况下，当CPU数量小于8个时，ParallelGCThreads 的值等于CPU数量，大于8个时，ParallelGCThreads的值等于3+((5*CPU_COUNT)/8)")]),a._v(" "),v("h3",{attrs:{id:"_2-2-新生代parallelgc回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-新生代parallelgc回收器"}},[a._v("#")]),a._v(" 2.2 新生代ParallelGC回收器")]),a._v(" "),v("p",[a._v("和ParNew回收器类似，但是又一个重要特点是该回收器非常关注系统的吞吐量")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("+XX:+UseParallelGC")]),a._v(":新生代使用ParallelGC回收器，老年代使用串行回收器")]),a._v(" "),v("li",[v("code",[a._v("+XX:+UseParallelOldGC")]),a._v(":新生代使用ParallelGC回收器，老年代使用ParallelOldGC回收器")])]),a._v(" "),v("p",[a._v("ParallelGC提供了两个重要参数用于控制系统的吞吐量：")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("-XX:MaxGCPauseMillis")]),a._v(":设置最大垃圾回收停顿时间。如果这个值设置很小，为了达到预期的停顿时间，虚拟机会使用较小的堆（小堆比大堆回收快），而将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低吞吐量。")]),a._v(" "),v("li",[v("code",[a._v("-XX:GCTimeRatio")]),a._v(":设置吞吐量大小。它的值是0-100之间的整数。GCTimeRatio默认值为19，则系统用于垃圾回收的时间不超过1/（1+19） = 5%。默认情况下，它的取值是99，即不超过1%的时间用于垃圾回收。")])]),a._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[a._v("这两个参数是相互矛盾的，如果减少回收的最大停顿时间，就会减少系统的吞吐量，增加系统吞吐量又可能增加回收的最大停顿时间")])]),a._v(" "),v("p",[a._v("还可以使用"),v("code",[a._v("-XX:+UseAdaptiveSizePolicy")]),a._v("开启自适应GC策略。在这种情况下，新生代的大小、eden和survivior比例、晋升老年代的对象年龄参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。")]),a._v(" "),v("h3",{attrs:{id:"_2-3-老年代paralleloldgc回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-老年代paralleloldgc回收器"}},[a._v("#")]),a._v(" 2.3 老年代ParallelOldGC回收器")]),a._v(" "),v("p",[a._v("一种多线程并发的回收器。和新生代ParallelGC回收器一样，也是关注吞吐量的收集器。使用"),v("code",[a._v("+XX:+UseParallelOldGC")]),a._v("开启老年代使用ParallelOldGC回收器，也可以使用"),v("code",[a._v("-XX:ParallelGCThreads")]),a._v("参数指定垃圾回收的线程数量")]),a._v(" "),v("h2",{attrs:{id:"三、cms回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、cms回收器"}},[a._v("#")]),a._v(" 三、CMS回收器")]),a._v(" "),v("p",[a._v("CMS（Concurrent Mark Sweep）回收器主要关注于系统停顿时间。使用的是标记清除算法，也是一个多线程并行回收的垃圾回收器。")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(539),alt:"CMS"}})])]),a._v(" "),v("p",[a._v("CMS收集器相对于其他收集器来说，相对流程较多，整体可分为4个步骤：")]),a._v(" "),v("ol",[v("li",[a._v("初始标记（仅仅标记GC Roots能直接关联到的对象，速度很快）")]),a._v(" "),v("li",[a._v("并发标记（从GCRoots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不用停顿用户线程）")]),a._v(" "),v("li",[a._v("重新标记（为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段停顿时间会比初始标记长一些）")]),a._v(" "),v("li",[a._v("并发清除（清理删除掉标记阶段判断的已死亡对象，由于使用的是标记清除法，所以不需要移动对象，且这个阶段也可以和用户线程并行）")]),a._v(" "),v("li",[a._v("并发重置（为下一次垃圾回收做准备）")])]),a._v(" "),v("p",[a._v("其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。标记操作都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象，并发重置则是在垃圾回收完成后，重新初始化CMS数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。")]),a._v(" "),v("p",[a._v("在默认情况下，并发标记后，会有一个预清理的操作（可以使用"),v("code",[a._v("-XX:-CMSPrecleaningEnabled")]),a._v("关闭预清理）。")]),a._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",[a._v("并发是指收集器和应用程序交替执行，并行是指应用程序停止，同时由多个线程一起执行GC。因此并行回收器并不是和应用程序并发的。因为并行回收器执行时，应用程序完全挂起，不存在交替执行的步骤")])]),a._v(" "),v("h4",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),v("ul",[v("li",[a._v("启用CMS回收器的参数是"),v("code",[a._v("-XX:+UseConcMarkSweepGC")]),a._v("。CMS默认启动的并发线程数是（ParallelGCThreads+3）/4。也就是当处理器核心数在4个以上时，垃圾回收资源相对占资源比较小，但是，当核心数小于4个时，就要注意，因为此时回收线程占用的资源相对来说是比较大的。因此，CMS提供自定义线程数，并发线程数可以通过"),v("code",[a._v("-XX:ConcGCThreads")]),a._v("或者"),v("code",[a._v("-XX:ParallelCMSThreads")]),a._v("参数手工设定")]),a._v(" "),v("li",[a._v("CMS收集器无法处理浮动垃圾（Floating Garbage）有可能出现"),v("code",[a._v("Con-current Mode Failure")]),a._v("并发失败进而导致另一次完全“STW”的FullGC。（由于并发标记和并发清理时是与用户线程并行的，所以在并发期间产生的垃圾无法在本次回收处理，因此称作为浮动垃圾）同时，因为应用程序没有中断，所以在CMS回收过程中，还应该确保应用程序由足够的内存够用。因此，CMS回收器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率大道某一个阈值时便开始进行回收，以确保应用程序在CMS工作过程中，仍然有足够的空间支持应用程序运行。这个回收阈值可以使用"),v("code",[a._v("-XX:CMSInitiatingOccupancyFraction")]),a._v("来指定，默认是68。即当老年代的空间使用率达到68%时，会执行一次CMS回收。如果应用程序的内存使用率增长很快，在CMS执行的过程中，已经出现内存不足的情况（并发失败），此时，CMS回收就会失败，虚拟机将启动老年代串行收集器进行垃圾回收。如果这样的情况发生，应用程序将完全中断，直到垃圾回收完成，这时的应用程序停顿时间可能会比较长。")]),a._v(" "),v("li",[a._v("由于CMS是一个基于标记清除算法的回收器。那么这种方法将会造成大量的内存碎片，离散的可用空间无法分配较大的对象。为了解决这个问题，CMS回收器还提供了几个用于内存压缩整理的参数。\n"),v("code",[a._v("-XX:+UseCMSCompactAtFullCollection")]),a._v("可以使CMS在垃圾收集完成后，进行一次碎片整理，内存碎片整理不是并发进行的。（默认开启，从JVM9开始废弃）\n"),v("code",[a._v("-XX:CMSFullGCsBeforeCompaction")]),a._v("可以用于设定进行多少次CMS回收后，进行一次内存压缩（从java9开始废弃）")])]),a._v(" "),v("p",[a._v("如果希望CMS回收MetaSpace区，则必须要打开"),v("code",[a._v("-XX:+CMSClassUnloadingEnabled")]),a._v("。开启后，如果条件允许，那么系统会使用CMS的机制回收Class数据")]),a._v(" "),v("h2",{attrs:{id:"四、g1收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、g1收集器"}},[a._v("#")]),a._v(" 四、G1收集器")]),a._v(" "),v("p",[a._v("G1是一款面向服务端的垃圾回收器（从jdk7开始孵化），它是作用是替换到JDK1.5中发布的CMS收集器，从JDK9之后称为默认的服务端垃圾收集器，而CMS也会被标注为不推荐使用的收集器。在G1之前，所有的收集器都是以分代为基础目标范围：新生代（Minor GC），老年代（Major GC）和整堆（Full GC）。而G1则可以面向堆的任何部分来组成回收集（Collection Set CSet）进行回收，衡量标准不是以代做区分，而是那块内存中存放的垃圾比较多，回收效益大，也就是G1的MixedGC模式。")]),a._v(" "),v("p",[a._v("实现是G1把连续的Java堆划分为多个大小相等的独立区域（Region）每一个Region都可以根据需要，扮演新生代的Eden区、Survivor区和老年代空间。Regoin中还存在一个特殊区域Humangous区域，专门存储大对象，当一个对象大小超过Region的一半大小时，就被认为是大对象。可以通过参数"),v("code",[a._v("-XX:G1HeapRegionSize")]),a._v("设定。如果一个超级大对象超过多个Region，则会存放在N个连续的Humangous Region之中（被视为老年代）")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(540),alt:"G1"}})])]),a._v(" "),v("h3",{attrs:{id:"_4-1面对的难题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1面对的难题"}},[a._v("#")]),a._v(" 4.1面对的难题")]),a._v(" "),v("h4",{attrs:{id:"跨region的引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨region的引用"}},[a._v("#")]),a._v(" 跨Region的引用")]),a._v(" "),v("p",[a._v("跨代的引用中，使用"),v("RouterLink",{attrs:{to:"/java/jvm/garbage.html#24-记忆集与卡表"}},[a._v("记忆集")]),a._v("来避免全堆作为GCRoots扫描。但在G1中记忆集本质上就是一个哈希表，使用Region的起始地址作为key，Value为存储的元素是卡表的索引集合。这种卡表的双向结构（卡表是我指向谁，这种记录了谁指向我）比原来的卡表结构更复杂，同时Region的数量远比分区的数量要多很多，因此会占用更高的内存。根据经验，G1至少也要占用大约相当与堆容量的10%-20%额外内存来支持收集工作。")],1),a._v(" "),v("h4",{attrs:{id:"收集线程和用户线程互不归干扰"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#收集线程和用户线程互不归干扰"}},[a._v("#")]),a._v(" 收集线程和用户线程互不归干扰")]),a._v(" "),v("p",[a._v("首要目的是标记期间不能打破对象原有引用的对象图结构，在CMS中使用增量更新算法去重新标记对象，而G1使用的是原始快照的方式来实现。其次是回收过程中新对象的分配，G1为每个Region设计了两个名为TAMS（Top at Mark Start）指针（指针之上标记的都为存活对象），在并发回收期间新分配的对象地址都要在这两个指针之上，不纳入回收范围。与CMS的“Concurrent Mode Failure”失败导致Full GC类似，G1在垃圾回收速度赶不上内存分配速度时，也会产生FullGC导致STW")]),a._v(" "),v("h4",{attrs:{id:"可靠的停顿预测模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可靠的停顿预测模型"}},[a._v("#")]),a._v(" 可靠的停顿预测模型")]),a._v(" "),v("p",[a._v("收集器会记录每个Region回收耗时，、每个Region记忆集中的脏卡数量等各个可预测的花费成本，得出平均值、标准偏差、置信度等信息。然后通过这些信息预测停顿期望的时间约束下的最高收益。")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(541),alt:"G1"}})])]),a._v(" "),v("p",[a._v("在不维护remembered set的操作情况下，G1操作分为以下几个步骤：")]),a._v(" "),v("ul",[v("li",[a._v("初始标记\n标记GC Roots能直接关联的对象，并且修改TAMS（next top at mark Start）的值，让下一阶段用户程序并发运行，这段时间需要停顿线程，但是耗时很短。")]),a._v(" "),v("li",[a._v("并发标记\n从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这阶段耗时较长，但是可以用户程序并发执行。")]),a._v(" "),v("li",[a._v("最终标记\n为了修正在并发标记过程中由于用户线程运行导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象记录在线程remembered Set logs里。同时需要把remembered Set logs的数据合并到Remembered set中，这阶段将停止线程，但是可并行执行。")]),a._v(" "),v("li",[a._v("筛选回收\n首先对region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个步骤也需要停止用户线程。")])]),a._v(" "),v("h3",{attrs:{id:"_4-2-优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-优点"}},[a._v("#")]),a._v(" 4.2 优点")]),a._v(" "),v("p",[a._v("与其他收集器相比，G1具有以下优点：")]),a._v(" "),v("ul",[v("li",[a._v("并行与并发\n利用多核CPU来缩短Stop the world停顿的时间，G1收集器可以通过并发的方式让Java程序与GC并发执行。")]),a._v(" "),v("li",[a._v("分代收集\nG1收集器任然保留分代收集的方式；\nG1收集器可以不需要其他收集器配合就能单独管理整个堆，它可以采用不同的方式处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象从而获得更好的收集效果。")]),a._v(" "),v("li",[a._v("空间整理\n与GMS的“标记-清除”算法不同，G1收集器从整理上看是“标记-整理”算法实现的收集器，从局部看（两个Region之间）上看是基于“复制”算法实现的，从这两种算法来看那G1运行期间不会产生内存空间碎片，收集器能提供规整的可用空间，这种特性有利于程序长时间运行，分配大对象时不会因为无法分配到连续的内存空间而提前触发下一次GC。")]),a._v(" "),v("li",[a._v("可预测的停顿\nG1相比于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型：能让使用者明确指出在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。")])]),a._v(" "),v("p",[a._v("使用参数"),v("code",[a._v("-XX:+UseG1GC")]),a._v("打开G1收集器。最重要的参数是"),v("code",[a._v("-XX:MaxGCPauseMillis")]),a._v("，它用于指定目标最大停顿时间。如果任何一次停顿时间超过这个设置值时，G1就会尝试调整新生代和老年代的比例、堆的大小、晋升年龄等手段来达到预设的目标。此外，"),v("code",[a._v("-XX:InitiatingHeapOccupancyPercent")]),a._v("参数设定当前堆使用率达到多少时，出发并发标记周期的执行。默认为45，即当整个堆占用率达到45%时，执行并发标记周期。而且这个值一旦设置，始终都不会被G1收集器修改，这意味着G1收集器不会试图改变这个值来满足MaxGCPauseMillis的目标。")]),a._v(" "),v("h2",{attrs:{id:"五、shenandoah收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、shenandoah收集器"}},[a._v("#")]),a._v(" 五、Shenandoah收集器")]),a._v(" "),v("p",[a._v("非官方的收集器，由RedHat公司开发，所以只能在OpenJDK中使用。\nShenandoah与G1有三个明显的区别：")]),a._v(" "),v("ul",[v("li",[a._v("支持并行的整理算法")]),a._v(" "),v("li",[a._v("默认不使用分代收集")]),a._v(" "),v("li",[a._v("不再使用记忆集，而是使用连接矩阵（全局数据结构记录跨Region的引用关系）")])]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(542),alt:"Shenandoah"}})])]),a._v(" "),v("p",[a._v("使用并行的整理算法，整理算法都需要复制对象，而复制对象的同时也要和用户线程并行是一件比较棘手的事情。shenandoah使用读屏障和被称为“brooks pointers”的转发指针来解决，也就是为什么收集器还要在最后进行更新引用的原因。")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(543),alt:"brooks pointers"}})])]),a._v(" "),v("p",[a._v("如图所示，由以下流程进行：")]),a._v(" "),v("ol",[v("li",[a._v("收集器线程复制了新的对象副本")]),a._v(" "),v("li",[a._v("用户线程更新了对象的某个字段")]),a._v(" "),v("li",[a._v("收集器线程更新转发指针的引用值为新副本地址")])]),a._v(" "),v("p",[a._v("以上流程在并发的情况下，相对于读来说，无论读到旧对象还是新对象返回结果都是一样的。而对于并发写入来说，就一定要保证写入的对象为新复制的对象。\n比如流程2在1或者3之前进行，那就会出现问题，所以这里对并发指针的操作必须同步进行，让用户线程和回收线程对转发指针的访问只有一个能成功，另外一个必须等待。实际上此处使用的是CAS操作来保证并发的。")]),a._v(" "),v("p",[a._v("另外一个特点就是读屏障。通过对象头的转发指针来保证并发时原对象与复制对象的访问一致性。对象的访问包括读取、写入、比较、哈希值计算、加锁等，所以shenandoah使用了读屏障和写屏障去拦截这些操作，保证访问的一致性。当然，使用读屏障的代价是比写屏障更大的，因为对象的读取频率是比写入频率要高很多的，因此读屏障势必比写屏障要多。收集器的设计者也注意到了这一点，所以在JDK13后，将shennandoah的内存屏障模型改进为基于引用访问屏障，也就是只对引用类型操作的读写屏障，不对基础数据类型的操作进行设置内存屏障。")]),a._v(" "),v("h2",{attrs:{id:"六、zgc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、zgc"}},[a._v("#")]),a._v(" 六、ZGC")]),a._v(" "),v("p",[a._v("ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。")]),a._v(" "),v("p",[a._v("与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但不同的是，ZGC的Region（ZRegion）具有动态性，动态地创建销毁以及动态的区域容量大小。")]),a._v(" "),v("ul",[v("li",[a._v("小型Region ：固定容量2MB，用于放置小于256K的小对象")]),a._v(" "),v("li",[a._v("中型Region：固定容量为32MB，用于放置大于等于256K但小于4MB的对象。")]),a._v(" "),v("li",[a._v("大型Region：不固定容量，可以动态变化，但必须为2MB的整数倍。")])]),a._v(" "),v("p",[a._v("并发整理算法的实现：Shenandoah使用转发指针和读屏障来实现并发整理。\n但ZGC采用的是染色指针。染色指针是一种直接将少量额外的信息存储在指针上的技术")]),a._v(" "),v("center",[v("p",[v("img",{attrs:{src:_(544),alt:"Colorful pointers"}})])]),a._v(" "),v("p",[a._v("ZGC的染色指针技术是在将64位的对象指针内做标记的，这样可以直接从指针中看到引用对象的三色标记状态、是否重分配集（即被移动过）、是否只能通过finalize（）方法才能被访问到。")]),a._v(" "),v("p",[a._v("总体来说，染色指针的三大优势为：")]),a._v(" "),v("ul",[v("li",[a._v("染色指针可以使得一旦某个Region内的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。")]),a._v(" "),v("li",[a._v("染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然可以省去专门的记录操作。")]),a._v(" "),v("li",[a._v("染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。")])])],1)}),[],!1,null,null,null);e.default=t.exports}}]);